@model Tidbeat.Models.Conversation
@using Tidbeat.Enums

@{
    ViewData["Title"] = "Details";
    var messageIndex = 0;
    var mostRecentCurrentUserMessageIndex = 0;
    foreach(var message in ViewBag.Messages)
    {
        if (message.User.Id == ViewBag.CurrentUser.Id)
        {
            mostRecentCurrentUserMessageIndex = messageIndex;
        }
        messageIndex++;
    }
    messageIndex = 0;
}

<h1>Details</h1>

<h2 class="text-center" style="margin-top: 0; padding-top: 30px; padding-bottom: 30px;">@ViewBag.CurrentUser.FullName > @ViewBag.OtherUser.FullName</h2>
<div class="container" style="height: calc(100% - 110px);">
    <div id="messages" style="background-color: whitesmoke; ">
        <button type="button" id="getRecentMessagesButton" class="@(ViewBag.Messages.Count >= 20 ? "" : "d-none")">More messages...</button>
        @foreach (var message in ViewBag.Messages)
        {
            @if (message.User.Id == ViewBag.CurrentUser.Id)
            {
                @if (messageIndex == mostRecentCurrentUserMessageIndex) {
                    <div class="message-entry">
                        <div class="message-avatar pull-right">@message.User.FullName</div>
                        <div class="d-flex flex-column pull-right">
                            <div class="message-content pull-right" style="max-width: 400px;">@message.Text</div>
                            <div id="status-message" class="pull-right">@((message.Status == (int)MessageStatus.Sent) ? "Enviado" : "Lido" )</div>
                        </div>
                    </div>
                }
                else
                {
                    <div class="message-entry">
                        <div class="message-avatar pull-right">@message.User.FullName</div>
                        <div class="message-content pull-right">@message.Text</div>
                    </div>
                }
            }
            else
            {
                <div class="message-entry">
                    <div class="message-avatar pull-left">@message.User.FullName</div>
                    <div class="message-content pull-left">@message.Text</div>
                </div>
            }
            messageIndex++;
        }
    </div>
    <div style="width: 100%; border-left-style: ridge; border-right-style: ridge;">
        <textarea id="message"
                  style="width: 100%; padding: 5px 10px; border-style: hidden;"
                  placeholder="Type message and press Enter to send..."></textarea>
    </div>
    <div style="overflow: auto; border-style: ridge; border-top-style: hidden;">
        <button class="btn-warning pull-right" id="echo">Echo</button>
        <button class="btn-success pull-right" id="sendmessage">Send</button>
    </div>
</div>
<div class="modal alert alert-danger fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
    <div class="modal-dialog" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <div>Connection Error...</div>
                <div><strong style="font-size: 1.5em;">Hit Refresh/F5</strong> to rejoin. ;)</div>
            </div>
        </div>
    </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.4/signalr.min.js" integrity="sha512-ulHhwQdGlX96gNSRsakG06STFdaQBUTbCX4KqLcYI428blEsttMkg2C3n2KtiYNDwnETBHXDg9ZAtvkfMHTYOQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script type="text/javascript">
    document.addEventListener('DOMContentLoaded', function () {

        const generateRandomName = () =>
            Math.random().toString(36).substring(2, 10);

        let username = generateRandomName();
        const promptMessage = 'Enter your name:';
        do {
            username = "@ViewBag.CurrentUser.FullName";
            if (!username || username.startsWith('_') || username.indexOf('<') > -1 || username.indexOf('>') > -1) {
                username = '';
                promptMessage = 'Invalid input. Enter your name:';
            }
        } while (!username)

        const messageInput = document.getElementById('message');
        messageInput.focus();

        function createMessageEntry(encodedName, encodedMsg) {
            var entry = document.createElement('div');
            let statusMessage = document.getElementById('status-message');
            entry.classList.add("message-entry");
            if (encodedName === "_SYSTEM_") {
                entry.innerHTML = encodedMsg;
                entry.classList.add("text-center");
                entry.classList.add("system-message");
            } else if (encodedName === "_BROADCAST_") {
                entry.classList.add("text-center");
                entry.innerHTML = `<div class="text-center broadcast-message">${encodedMsg}</div>`;
            } else if (encodedName === username) {
                if (statusMessage) {
                    statusMessage.remove();
                }
                entry.innerHTML = `<div class="message-avatar pull-right">${encodedName}</div>` +
                    `<div class="d-flex flex-column pull-right">
                        <div class="message-content" style="max-width: 400px;">${encodedMsg}</div>
                        <div class="pull-right" id="status-message">Enviado</div>
                    </div>`;
            } else {
                entry.innerHTML = `<div class="message-avatar pull-left">${encodedName}</div>` +
                    `<div class="message-content pull-left">${encodedMsg}<div>`;
            }
            return entry;
        }

        function bindConnectionMessage(connection) {
            var messageCallback = function (name, message) {
                if (!message) return;
                var encodedName = name;
                var encodedMsg = message.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                var messageEntry = createMessageEntry(encodedName, encodedMsg);

                let statusMessage = document.getElementById('status-message');

                var messageBox = document.getElementById('messages');
                messageBox.appendChild(messageEntry);
                messageBox.scrollTop = messageBox.scrollHeight;
                connection.send('setSeenMessages', '@Model.Id', '@ViewBag.OtherUser.Id');
            };
            var seenCallback = function (userId) {
                if (userId === '@ViewBag.CurrentUser.Id') {
                    let statusMessage = document.getElementById('status-message');
                    if (statusMessage) {
                        statusMessage.innerHTML = "Lido";
                    }
                }
            };
            connection.on('broadcastMessage', messageCallback);
            connection.on('setSeenMessages', seenCallback);
            connection.on('echo', messageCallback);
            connection.onclose(onConnectionError);
        }
        
        function setOtherUsersMessageToSeenInDatabase() {
            fetch('/Conversations/SetUsersMessagesToSeen', {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    userId: '@ViewBag.OtherUser.Id',
                    conversationId: '@Model.Id'
                })
            })
        }

        function saveMessageInDb(message) {
            fetch('/Conversations/SaveMessage', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text: message,
                    userId: '@ViewBag.CurrentUser.Id',
                    conversationId: '@Model.Id'
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log(data); // success response from server
            })
            .catch(error => {
                console.error('There was a problem with the fetch operation:', error);
            });
        }
        
        function onConnected(connection) {
            console.log('connection started');
            connection.send('joinChat', '@Model.Id');
            connection.send('broadcastMessage', '@Model.Id', '_SYSTEM_', username + ' JOINED');
            connection.send('setSeenMessages', '@Model.Id', '@ViewBag.OtherUser.Id');
            setOtherUsersMessageToSeenInDatabase();
            document.getElementById('sendmessage').addEventListener('click', function (event) {
                if (messageInput.value) {
                    connection.send('broadcastMessage', '@Model.Id', username, messageInput.value);
                    saveMessageInDb(messageInput.value);
                }

                messageInput.value = '';
                messageInput.focus();
                event.preventDefault();
            });
            document.getElementById('message').addEventListener('keypress', function (event) {
                if (event.keyCode === 13) {
                    event.preventDefault();
                    document.getElementById('sendmessage').click();
                    return false;
                }
            });
            document.getElementById('echo').addEventListener('click', function (event) {
                connection.send('echo', username, messageInput.value);

                messageInput.value = '';
                messageInput.focus();
                event.preventDefault();
            });
        }

        function onConnectionError(error) {
            if (error && error.message) {
                console.error(error.message);
            }
            //connection.send('leaveChat', '@Model.Id');
            var modal = document.getElementById('myModal');
            modal.classList.add('in');
            modal.style = 'display: block;';
        }

        const connection = new signalR.HubConnectionBuilder()
            .withUrl('/chat')
            .build();
        bindConnectionMessage(connection);
        connection.start()
            .then(() => onConnected(connection))
            .catch(error => console.error(error.message));
    });

    
    const getRecentMessagesButton = document.getElementById('getRecentMessagesButton');
    const messagesContainer = document.getElementById('messages');
    var skipAmount = @ViewBag.Messages.Count;

    getRecentMessagesButton.addEventListener('click', async () => {
        try {
            const conversationId = "@Model.Id";
            const messageAmount = @ViewBag.MessageAmountPerCall;

            const response = await fetch('/Conversations/GetRecentMessages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    conversationId: conversationId,
                    messageAmount: messageAmount,
                    skipAmount: skipAmount
                })
            });

            if (!response.ok) {
                throw new Error('Error getting recent messages.');
            }

            const messages = await response.json();
            console.log(messages);
            skipAmount += messages.length;
            updateMessagesContainer(messages);
        } catch (error) {
            console.error(error);
        }
    });

    function updateMessagesContainer(messages) {
        let messageIndex = 0;
        let statusMessage = document.getElementById('status-message');
        let statusMessageAlreadyExists = statusMessage !== null;

        let mostRecentMessageIndex = -1;
        for (let i = 0; i < messages.length; i++) {
            if (messages[i].user.id === "@ViewBag.CurrentUser.Id" && mostRecentMessageIndex == -1) {
                mostRecentMessageIndex = i;
            }
        }

        messages.forEach((message) => {
            const messageElement = document.createElement('div');
            messageElement.classList.add("message-entry");
            if (message.user.id === "@(ViewBag.CurrentUser.Id)") {
                if (messageIndex == mostRecentMessageIndex && !statusMessageAlreadyExists) {
                    messageElement.innerHTML =
                        `<div class="message-avatar pull-right">${message.user.fullName}</div>` +
                        `<div class="d-flex flex-column pull-right">
                            <div class="message-content" style="max-width: 400px;">${message.text}</div>
                            <div class="pull-right"  id="status-message">${message.status === @((int)MessageStatus.Sent) ? "Enviado" : "Lido"}</div>
                        </div>`;
                } else {
                    messageElement.innerHTML = 
                    `<div class="message-avatar pull-right">${message.user.fullName}</div>` +
                    `<div class="message-content pull-right" style="max-width: 400px;">${message.text}</div>`
                }
            } else {
                messageElement.innerHTML = `<div class="message-avatar pull-left">${message.user.fullName}</div>` +
                    `<div class="message-content pull-left">${message.text}<div>`;
            }
            messageIndex++;
            messagesContainer.insertBefore(messageElement, messagesContainer.children[1]);
            if (messages.length < @ViewBag.MessageAmountPerCall) {
                getRecentMessagesButton.style.display = 'none';
            }
        });
    }
    

</script>